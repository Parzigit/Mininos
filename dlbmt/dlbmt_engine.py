"""
DLBMT Engine – Distributed Load Balancing Mechanism with Multi-level Threshold
Implements all formulas (Eq 1-10) and algorithms (Algorithm 1 & 2) from the paper:
"Enhanced load balancing technique for SDN controllers: A multi-threshold approach
 with migration of switches" (Computer Communications 238, 2025)
"""

import math
import time
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import IntEnum

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Constants & Enums
# ---------------------------------------------------------------------------

class ControllerLevel(IntEnum):
    """Multi-level threshold levels (Section 3.3.2)"""
    IDLE = 1       # Load < 25
    NORMAL = 2     # 25 <= Load < 50
    HIGH = 3       # 50 <= Load < 75
    OVERLOAD = 4   # Load >= 75

    @property
    def label(self):
        return {1: "Idle", 2: "Normal", 3: "High Load", 4: "Overload"}[self.value]

    @property
    def color(self):
        return {1: "#00ff88", 2: "#00d4ff", 3: "#ffaa00", 4: "#ff006e"}[self.value]


# Threshold boundaries Q[1..4]
THRESHOLDS = [25, 50, 75, 100]

# Default weight coefficients (a + b + c = 1)
DEFAULT_A = 0.4   # CPU weight
DEFAULT_B = 0.3   # Memory weight
DEFAULT_C = 0.3   # Bandwidth weight


# ---------------------------------------------------------------------------
# Data Classes
# ---------------------------------------------------------------------------

@dataclass
class Switch:
    """A switch in the SDN data plane."""
    id: str
    controller_id: str          # Which controller domain this switch belongs to
    load_cpu: float = 0.0       # CPU load generated by this switch's Packet-In traffic
    load_mem: float = 0.0       # Memory load generated
    load_bw: float = 0.0        # Bandwidth load generated
    packet_in_rate: float = 0.0 # Packet-In messages per second
    x: float = 0.0              # Position for topology visualization
    y: float = 0.0

    def to_dict(self):
        return {
            "id": self.id,
            "controller_id": self.controller_id,
            "load_cpu": round(self.load_cpu, 3),
            "load_mem": round(self.load_mem, 3),
            "load_bw": round(self.load_bw, 3),
            "packet_in_rate": round(self.packet_in_rate, 2),
            "x": self.x,
            "y": self.y,
        }


@dataclass
class Controller:
    """An SDN controller in the control plane."""
    id: str
    capacity_cpu: float = 2000.0    # Max CPU capacity (units)
    capacity_mem: float = 4096.0    # Max Memory capacity (MB)
    capacity_bw: float = 1000.0     # Max Bandwidth capacity (Mbps)
    level: ControllerLevel = ControllerLevel.NORMAL
    load_percentage: float = 0.0     # LR_cj (0-100)
    active: bool = True
    x: float = 0.0
    y: float = 0.0

    def to_dict(self):
        return {
            "id": self.id,
            "capacity_cpu": self.capacity_cpu,
            "capacity_mem": self.capacity_mem,
            "capacity_bw": self.capacity_bw,
            "level": self.level.value,
            "level_label": self.level.label,
            "level_color": self.level.color,
            "load_percentage": round(self.load_percentage, 2),
            "active": self.active,
            "x": self.x,
            "y": self.y,
        }


@dataclass
class MigrationRecord:
    """Record of a switch migration event."""
    timestamp: float
    switch_id: str
    source_controller: str
    target_controller: str
    source_load_before: float
    source_load_after: float
    target_load_before: float
    target_load_after: float
    migration_efficiency: float
    migration_cost: float
    imbalance_before: float
    imbalance_after: float

    def to_dict(self):
        return {
            "timestamp": self.timestamp,
            "time_str": time.strftime("%H:%M:%S", time.localtime(self.timestamp)),
            "switch_id": self.switch_id,
            "source_controller": self.source_controller,
            "target_controller": self.target_controller,
            "source_load_before": round(self.source_load_before, 2),
            "source_load_after": round(self.source_load_after, 2),
            "target_load_before": round(self.target_load_before, 2),
            "target_load_after": round(self.target_load_after, 2),
            "migration_efficiency": round(self.migration_efficiency, 6),
            "migration_cost": round(self.migration_cost, 4),
            "imbalance_before": round(self.imbalance_before, 4),
            "imbalance_after": round(self.imbalance_after, 4),
        }


# ---------------------------------------------------------------------------
# DLBMT Engine
# ---------------------------------------------------------------------------

class DLBMTEngine:
    """
    Core DLBMT algorithm engine.
    Implements load calculation, multi-level thresholding, and switch migration
    selection as described in the paper.
    """

    def __init__(self, a: float = DEFAULT_A, b: float = DEFAULT_B, c: float = DEFAULT_C):
        assert abs(a + b + c - 1.0) < 1e-6, "Coefficients a + b + c must equal 1"
        self.a = a
        self.b = b
        self.c = c

        self.controllers: Dict[str, Controller] = {}
        self.switches: Dict[str, Switch] = {}
        self.distance_matrix: Dict[Tuple[str, str], float] = {}  # (switch_id, ctrl_id) -> distance
        self.migration_history: List[MigrationRecord] = []
        self.load_history: List[dict] = []  # Time-series snapshots

    # -----------------------------------------------------------------------
    # Setup
    # -----------------------------------------------------------------------

    def add_controller(self, controller: Controller):
        self.controllers[controller.id] = controller

    def add_switch(self, switch: Switch):
        self.switches[switch.id] = switch

    def set_distance(self, switch_id: str, controller_id: str, distance: float):
        self.distance_matrix[(switch_id, controller_id)] = distance

    def get_distance(self, switch_id: str, controller_id: str) -> float:
        return self.distance_matrix.get((switch_id, controller_id), 1.0)

    def get_switches_in_domain(self, controller_id: str) -> List[Switch]:
        return [s for s in self.switches.values() if s.controller_id == controller_id]

    def get_active_controllers(self) -> List[Controller]:
        return [c for c in self.controllers.values() if c.active]

    # -----------------------------------------------------------------------
    # Eq. 1: Per-switch resource usage on controller
    # -----------------------------------------------------------------------

    def compute_switch_resource_usage(self, switch: Switch, controller: Controller) -> float:
        """
        Eq. 1: £_ji = a·(LoadCPU/CPU) + b·(LoadMem/Mem) + c·(LoadBw/Bw)
        Returns a value between 0 and 1.
        """
        cpu_ratio = switch.load_cpu / controller.capacity_cpu if controller.capacity_cpu > 0 else 0
        mem_ratio = switch.load_mem / controller.capacity_mem if controller.capacity_mem > 0 else 0
        bw_ratio = switch.load_bw / controller.capacity_bw if controller.capacity_bw > 0 else 0

        usage = self.a * cpu_ratio + self.b * mem_ratio + self.c * bw_ratio
        return min(usage, 1.0)

    # -----------------------------------------------------------------------
    # Eq. 2 & 3: Controller load calculation
    # -----------------------------------------------------------------------

    def compute_controller_load(self, controller_id: str) -> float:
        """
        Eq. 2: £_j = Σ £_ji for all switches in controller's domain
        Eq. 3: LR_cj = £_j * 100
        Returns load percentage (0-100).
        """
        controller = self.controllers[controller_id]
        switches = self.get_switches_in_domain(controller_id)

        total_usage = 0.0
        for switch in switches:
            total_usage += self.compute_switch_resource_usage(switch, controller)

        load_pct = total_usage * 100.0
        return min(load_pct, 100.0)

    # -----------------------------------------------------------------------
    # Algorithm 1: Multi-level threshold
    # -----------------------------------------------------------------------

    def determine_level(self, load: float) -> ControllerLevel:
        """
        Algorithm 1: Determine controller level based on load.
        Q[1]=25, Q[2]=50, Q[3]=75, Q[4]=100
        """
        for i, threshold in enumerate(THRESHOLDS):
            if load < threshold:
                return ControllerLevel(i + 1)
        return ControllerLevel.OVERLOAD

    def update_controller_levels(self) -> Dict[str, bool]:
        """
        Run Algorithm 1 for all controllers.
        Returns dict of controller_id -> whether level changed.
        """
        level_changes = {}
        for ctrl_id, ctrl in self.controllers.items():
            if not ctrl.active:
                continue
            load = self.compute_controller_load(ctrl_id)
            new_level = self.determine_level(load)
            old_level = ctrl.level

            ctrl.load_percentage = load
            ctrl.level = new_level
            level_changes[ctrl_id] = (old_level != new_level)

        return level_changes

    # -----------------------------------------------------------------------
    # Eq. 4: Migration candidate selection ratio
    # -----------------------------------------------------------------------

    def compute_migration_ratio(self, switch: Switch, controller: Controller) -> float:
        """
        Eq. 4: ψ_sji = (£_ji * 100) / h_mi
        Ratio of resources consumed by switch to distance from controller.
        """
        usage = self.compute_switch_resource_usage(switch, controller)
        distance = self.get_distance(switch.id, controller.id)
        if distance <= 0:
            distance = 1.0
        return (usage * 100.0) / distance

    # -----------------------------------------------------------------------
    # Eq. 5 & 6: Post-migration load calculation
    # -----------------------------------------------------------------------

    def compute_source_load_after_migration(self, source_ctrl: Controller,
                                             switch: Switch) -> float:
        """
        Eq. 5: LR*_cj = LR_cj - (£_ji * 100)
        """
        usage = self.compute_switch_resource_usage(switch, source_ctrl)
        return max(source_ctrl.load_percentage - (usage * 100.0), 0.0)

    def compute_target_load_after_migration(self, target_ctrl: Controller,
                                             switch: Switch) -> float:
        """
        Eq. 6: LR*_ck = LR_ck + (£_kij * 100)
        Eq. 7: £_kij = a·(LoadCPU/CPU_k) + b·(LoadMem/Mem_k) + c·(LoadBw/Bw_k)
        Uses target controller's capacity for the calculation.
        """
        # Eq. 7: Resource usage of switch on TARGET controller
        usage_on_target = self.compute_switch_resource_on_target(switch, target_ctrl)
        return target_ctrl.load_percentage + (usage_on_target * 100.0)

    def compute_switch_resource_on_target(self, switch: Switch,
                                           target_ctrl: Controller) -> float:
        """
        Eq. 7: £_kij = a·(LoadCPU/CPU_k) + b·(LoadMem/Mem_k) + c·(LoadBw/Bw_k)
        Resource usage of switch on the target controller (different capacity).
        """
        cpu_ratio = switch.load_cpu / target_ctrl.capacity_cpu if target_ctrl.capacity_cpu > 0 else 0
        mem_ratio = switch.load_mem / target_ctrl.capacity_mem if target_ctrl.capacity_mem > 0 else 0
        bw_ratio = switch.load_bw / target_ctrl.capacity_bw if target_ctrl.capacity_bw > 0 else 0

        usage = self.a * cpu_ratio + self.b * mem_ratio + self.c * bw_ratio
        return min(usage, 1.0)

    # -----------------------------------------------------------------------
    # Eq. 8: Degree of load imbalance
    # -----------------------------------------------------------------------

    def compute_degree_of_imbalance(self, lr_source_after: float, lr_target_after: float,
                                     avg_load_after: float) -> float:
        """
        Eq. 8: DC(c*j,ck) = sqrt(0.5 * ((LR*_cj - LR*)² + (LR*_ck - LR*)²)) / LR*
        """
        if avg_load_after <= 0:
            return float('inf')

        variance = 0.5 * ((lr_source_after - avg_load_after) ** 2 +
                          (lr_target_after - avg_load_after) ** 2)
        return math.sqrt(variance) / avg_load_after

    def compute_current_imbalance(self, source_id: str, target_id: str) -> float:
        """Compute degree of imbalance BEFORE migration (DC(cj,ck))."""
        source = self.controllers[source_id]
        target = self.controllers[target_id]
        active_ctrls = self.get_active_controllers()
        avg_load = sum(c.load_percentage for c in active_ctrls) / len(active_ctrls) if active_ctrls else 0

        if avg_load <= 0:
            return float('inf')

        variance = 0.5 * ((source.load_percentage - avg_load) ** 2 +
                          (target.load_percentage - avg_load) ** 2)
        return math.sqrt(variance) / avg_load

    # -----------------------------------------------------------------------
    # Eq. 9 & 10: Migration efficiency and cost
    # -----------------------------------------------------------------------

    def compute_migration_cost(self, switch: Switch, target_ctrl: Controller) -> float:
        """
        Eq. 10: f(sji, ck) = (£_kij * 100) · min(h_ik)
        """
        usage_on_target = self.compute_switch_resource_on_target(switch, target_ctrl)
        distance = self.get_distance(switch.id, target_ctrl.id)
        cost = (usage_on_target * 100.0) * distance
        return max(cost, 0.001)  # Avoid division by zero

    def compute_migration_efficiency(self, dc_after: float, dc_before: float,
                                      migration_cost: float) -> float:
        """
        Eq. 9: ϑ_jk = |DC*(cj,ck) - DC(cj,ck)| / f(sji, ck)
        """
        if migration_cost <= 0:
            return 0.0
        return abs(dc_after - dc_before) / migration_cost

    # -----------------------------------------------------------------------
    # Algorithm 2: Load Balancing (Full)
    # -----------------------------------------------------------------------

    def run_load_balancing(self) -> Optional[MigrationRecord]:
        """
        Algorithm 2: Complete load balancing algorithm.
        
        Steps:
        1. Update all controller levels
        2. For controllers at idle/high/overload level, find migration candidates
        3. Select best (switch, target_controller) pair based on migration efficiency
        4. Execute migration
        
        Returns MigrationRecord if a migration was performed, None otherwise.
        """
        # Step 1: Update levels
        level_changes = self.update_controller_levels()

        # Find controllers needing balancing (idle=1, high=3, overload=4)
        source_controllers = []
        for ctrl_id, ctrl in self.controllers.items():
            if not ctrl.active:
                continue
            if ctrl.level in (ControllerLevel.HIGH, ControllerLevel.OVERLOAD):
                source_controllers.append(ctrl)

        # Also handle idle controllers (they can donate switches)
        idle_controllers = [c for c in self.controllers.values()
                           if c.active and c.level == ControllerLevel.IDLE]

        if not source_controllers:
            return None

        best_pair = None
        best_efficiency = float('inf')  # Lower efficiency = better pair (paper says "least efficiency")

        for source_ctrl in source_controllers:
            result = self._find_best_migration_for_source(source_ctrl)
            if result is not None:
                switch, target_ctrl, efficiency, record_data = result
                if efficiency < best_efficiency:
                    best_efficiency = efficiency
                    best_pair = (switch, source_ctrl, target_ctrl, record_data)

        if best_pair is None:
            # No suitable migration found
            # For overloaded controllers: would add new controller (sim limitation)
            logger.info("No suitable migration found for any overloaded controller")
            return None

        # Execute migration
        switch, source_ctrl, target_ctrl, record_data = best_pair
        return self._execute_migration(switch, source_ctrl, target_ctrl, record_data)

    def _find_best_migration_for_source(self, source_ctrl: Controller):
        """
        For a given source controller, find the best (switch, target) pair.
        Implements Algorithm 2 steps 2-37.
        """
        domain_switches = self.get_switches_in_domain(source_ctrl.id)
        if not domain_switches:
            return None

        # Steps 2-9: Find migration candidates (ρ)
        # Compute ψ for all switches in domain
        ratios = {}
        for switch in domain_switches:
            ratios[switch.id] = self.compute_migration_ratio(switch, source_ctrl)

        if not ratios:
            return None

        avg_ratio = sum(ratios.values()) / len(ratios)

        # Switches with ratio >= average are migration candidates
        migration_candidates = [s for s in domain_switches if ratios[s.id] >= avg_ratio]

        if not migration_candidates:
            return None

        # Steps 10-24: For each candidate switch, find best target controller
        # Store pairs (switch, target_ctrl, dc_after)
        valid_pairs = []

        for switch in migration_candidates:
            best_target = None
            best_dc = float('inf')

            for target_ctrl in self.get_active_controllers():
                if target_ctrl.id == source_ctrl.id:
                    continue
                if target_ctrl.level not in (ControllerLevel.IDLE, ControllerLevel.NORMAL):
                    continue

                # Compute post-migration loads (Eq. 5, 6)
                lr_source_after = self.compute_source_load_after_migration(
                    source_ctrl, switch)
                lr_target_after = self.compute_target_load_after_migration(
                    target_ctrl, switch)

                # Check target level after migration
                target_level_after = self.determine_level(lr_target_after)
                if target_level_after not in (ControllerLevel.IDLE, ControllerLevel.NORMAL):
                    continue  # Remove from candidate list

                # Compute average load after migration
                active_ctrls = self.get_active_controllers()
                total_load = sum(c.load_percentage for c in active_ctrls)
                # Adjust total for the migration
                total_load = total_load - source_ctrl.load_percentage + lr_source_after
                total_load = total_load - target_ctrl.load_percentage + lr_target_after
                avg_load_after = total_load / len(active_ctrls)

                # Eq. 8: Degree of load imbalance after migration
                dc_after = self.compute_degree_of_imbalance(
                    lr_source_after, lr_target_after, avg_load_after)

                if dc_after < best_dc:
                    best_dc = dc_after
                    best_target = target_ctrl
                    best_record = {
                        "lr_source_after": lr_source_after,
                        "lr_target_after": lr_target_after,
                        "dc_after": dc_after,
                    }

            if best_target is not None:
                valid_pairs.append((switch, best_target, best_dc, best_record))

        if not valid_pairs:
            return None

        # Steps 30-37: Among valid pairs, select the one with best (least) migration efficiency
        best_result = None
        best_efficiency = float('inf')

        for switch, target_ctrl, dc_after, record_data in valid_pairs:
            # Eq. 8: DC before migration
            dc_before = self.compute_current_imbalance(source_ctrl.id, target_ctrl.id)

            # Eq. 10: Migration cost
            cost = self.compute_migration_cost(switch, target_ctrl)

            # Eq. 9: Migration efficiency
            efficiency = self.compute_migration_efficiency(dc_after, dc_before, cost)

            if efficiency < best_efficiency:
                best_efficiency = efficiency
                record_data["dc_before"] = dc_before
                record_data["cost"] = cost
                record_data["efficiency"] = efficiency
                best_result = (switch, target_ctrl, efficiency, record_data)

        return best_result

    def _execute_migration(self, switch: Switch, source_ctrl: Controller,
                           target_ctrl: Controller, record_data: dict) -> MigrationRecord:
        """Execute the switch migration and record it."""
        src_load_before = source_ctrl.load_percentage
        tgt_load_before = target_ctrl.load_percentage

        # Perform migration
        switch.controller_id = target_ctrl.id

        # Recalculate loads
        self.update_controller_levels()

        record = MigrationRecord(
            timestamp=time.time(),
            switch_id=switch.id,
            source_controller=source_ctrl.id,
            target_controller=target_ctrl.id,
            source_load_before=src_load_before,
            source_load_after=source_ctrl.load_percentage,
            target_load_before=tgt_load_before,
            target_load_after=target_ctrl.load_percentage,
            migration_efficiency=record_data.get("efficiency", 0),
            migration_cost=record_data.get("cost", 0),
            imbalance_before=record_data.get("dc_before", 0),
            imbalance_after=record_data.get("dc_after", 0),
        )

        self.migration_history.append(record)
        logger.info(
            f"Migration: {switch.id} from {source_ctrl.id} → {target_ctrl.id} | "
            f"Src load: {src_load_before:.1f}→{source_ctrl.load_percentage:.1f} | "
            f"Tgt load: {tgt_load_before:.1f}→{target_ctrl.load_percentage:.1f}"
        )
        return record

    # -----------------------------------------------------------------------
    # Snapshot for time-series
    # -----------------------------------------------------------------------

    def take_snapshot(self) -> dict:
        """Capture current state for time-series tracking."""
        active = self.get_active_controllers()
        avg_load = sum(c.load_percentage for c in active) / len(active) if active else 0

        # Compute global imbalance
        if active and avg_load > 0:
            variance = sum((c.load_percentage - avg_load) ** 2 for c in active) / len(active)
            global_imbalance = math.sqrt(variance) / avg_load
        else:
            global_imbalance = 0

        snapshot = {
            "timestamp": time.time(),
            "controllers": {c.id: {
                "load": round(c.load_percentage, 2),
                "level": c.level.value,
                "level_label": c.level.label,
            } for c in active},
            "avg_load": round(avg_load, 2),
            "global_imbalance": round(global_imbalance, 4),
            "total_switches": len(self.switches),
            "total_migrations": len(self.migration_history),
        }
        self.load_history.append(snapshot)

        # Keep only last 300 snapshots (5 min at 1/sec)
        if len(self.load_history) > 300:
            self.load_history = self.load_history[-300:]

        return snapshot

    def get_stats(self) -> dict:
        """Get comprehensive stats for the dashboard."""
        active = self.get_active_controllers()
        avg_load = sum(c.load_percentage for c in active) / len(active) if active else 0

        if active and avg_load > 0:
            variance = sum((c.load_percentage - avg_load) ** 2 for c in active) / len(active)
            global_imbalance = math.sqrt(variance) / avg_load
        else:
            global_imbalance = 0

        # Controller domain sizes
        domain_sizes = {}
        for ctrl in active:
            domain_sizes[ctrl.id] = len(self.get_switches_in_domain(ctrl.id))

        return {
            "avg_load": round(avg_load, 2),
            "global_imbalance": round(global_imbalance, 4),
            "total_controllers": len(active),
            "total_switches": len(self.switches),
            "total_migrations": len(self.migration_history),
            "domain_sizes": domain_sizes,
            "controller_loads": {c.id: round(c.load_percentage, 2) for c in active},
            "controller_levels": {c.id: c.level.label for c in active},
        }
